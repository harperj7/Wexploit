<?php namespace App\Http\Controllers;

use App\Http\Requests;
use App\Http\Controllers\Controller;
use App\ExploitType;
use App\Exploits;
use Mail;

use Illuminate\Http\Request;

class ExploitsController extends Controller {

	public function __construct() {

		//Make sure that the user is authorised to view this page/use the associated functions
		$this->middleware('auth');
	}

	// This function is used to display the index page for the exploits
	public function index() {

		// Retrieve all of the published exploits from the database
		$exploits = Exploits::all();

		// Display the exploits.index template - passing the retrieved exploits information to it
		return view('exploits.index', compact('exploits'));

	}

	//This function is called when the user accesses the Submit an exploit page
	public function create() {

		$exploit_types = ExploitType::lists('name', 'id');

		return view('exploits.create', compact('exploit_types'));

	}

	//Processes the submitted exploit and displays the Confirm page
	public function confirm(Requests\PrepareExploitRequest $request) {

		$data = $request->all() + [
			'name' => \Auth::user()->name,
			'email' => \Auth::user()->email
		];

		$template = view()->file(app_path('Http/Templates/exploit.blade.php'), $data);

		session()->flash('exploit', $data);

		return view('exploits.confirm', compact('template'));

	}

	//This function is used to generate a basic signature for the exploit submitted, based on the information submitted in the form
	public function generateSignature($data) {

		$exploits = new Exploits;

		//Retrieve the id of the previously added exploit from the database
		$previous_id = $exploits->orderBy('id', 'DESC')->pluck('id');
        $exploit_id = ($previous_id != null) ? ($previous_id + 1) : 1;

        //Based on the vulnerability category of the submitted exploit
        switch ($data['exploit_type']) {
        	case '1': //SQL Injection
        		$exploit_type = 'SI';
        		break;
        	case '2': //Remote Code Injection
        		$exploit_type = 'RCI';
        		break;
        	case '3': //XSS
        		$exploit_type = 'X';
        		break;
        	case '4': //CSRF
        		$exploit_type = 'C';
        		break;
        	case '5': //Privilege Escalation
        		$exploit_type = 'PE';
        		break;
        }

        //The language of the exploit
        $lang = strtoupper(substr($data['exploit_code_language'], 0, 3));

        //The reliability score of the exploit
        $reliability = (int)$data['reliability'];

        //Concatenate the elements of the signature
        $signature = $exploit_id . $exploit_type . $lang . $reliability;

        //Return the generated signature
		return [
			'signature' => $signature
		];
	}

	//Used to store the information submitted about an exploit into the database
	public function store(Request $request) {

		//Retrieve the information sent to the Confirm page. Append the generated signature to the data.
		$data = session()->get('exploit');
		$data += $this->generateSignature($data);

		//Save the exploit information to the database
		$exploit = Exploits::open($data)->useTemplate($request->input('template'));
		$exploit = \Auth::user()->exploits()->save($exploit);

		//Add an email to the email queue so the administrator of the application will be notified when a new exploit is submitted
		Mail::queue(['text' => 'emails.new-exploit'], compact('exploit'), function($message) use ($exploit) {

			$message->from('exploit-bot@wexploit.com')
					->to('jon@jharper.email')
					->subject('New exploit submitted');

		});

		//Display a message to the user stating that the exploit was successfully submitted
		flash('Exploit successfully submitted.');
		
		//Redirect the user back to the exploits index page
		return redirect('exploits');

	}

	//Called when the user goes to the Exploit details page
	public function show($exploitId) {

		//Find the exploit in the database by id
		$exploit = Exploits::find($exploitId);

		//Return the exploits.show template to the user - passing the exploit information to it
		return view('exploits.show', compact('exploit'));
	}

}
